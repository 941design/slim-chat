* TODO

+ make sidebar width adjustable
+ allow pasting/scanning public key hex as well
+ avatar next to each message

+ username vs. display name
+ cache profile images -> doc
+ consolidate documentation
+ use a config file format that can be commented
+ on network connection loss during download, resume
+ bug: download status does not update in a timely manner
+ view and edit profiles
  + send profile info as wrapped NIP-59 kind:0 event
  + create unit test to test fan out to all contacts in one wrapped event
+ developer mode where messages can be inspected on double click (modal overlay); requires --dev flag
+ amethyst sent this: `[//]: # (nip18)`
  + examine what message type that was
+ in header indicate what the main area currently displays: chat with ..., settings, about, etc.
+ clickable links
+ html/markdown messages
+ backup
+ forbid to add self as contact
+ consider direct link via ipv6
  + status?

** TODO [#A] Themes

+ save custom themes
+ one dark one light each
+ banner image
+ more fonts
+ theme generator
  + background
  + avatar
  + banner
  + reuse color theme
+ each color theme should provide dark and light variant
+ cancel/undo/revert/save
+ fonts
  + heading?
  + footer/info
  + contact/identities (headers)
  + messages self/other
+ transition when switching themes
+ background colors: 7
  + main panel
  + message cards (2)
  + side bar
  + footer
  + header
  + chat window
+ light gradient
  + matching text colors
  + matching label colors
+ card corner radius

⏺ There are 10 background colors in the theme system:

  Layout backgrounds (5):
  1. appBg - Main application shell
  2. surfaceBg - Cards, panels, header, footer
  3. surfaceBgSubtle - Subtle surfaces (hover states)
  4. surfaceBgSelected - Selected items
  5. menuBg - Dropdown menus

  Component backgrounds (5):
  6. buttonPrimaryBg - Primary buttons
  7. buttonSecondaryBg - Secondary buttons
  8. buttonDangerBg - Danger buttons
  9. inputBg - Input fields
  10. ownBubbleBg - User's outgoing message bubbles

** TODO [#B] remove legacy handlers

⏺ Legacy handlers are backward-compatibility aliases for older IPC channel names that were used before the codebase was refactored to use
  a domain-based naming convention.

  Looking at src/main/ipc/handlers.ts:351-370:

  // BUG FIX: Legacy IPC handlers for backward compatibility
  // Root cause: E2E tests using old API channel names (status:get, update:check, update:restart)
  ipcMain.handle('status:get', async () => {
    return dependencies.getStatus();
  });

  ipcMain.handle('update:check', async () => {
    return dependencies.checkForUpdates();
  });

  ipcMain.handle('update:restart', async () => {
    return dependencies.restartToUpdate();
  });

  These 3 legacy handlers map to the same functionality as their newer counterparts:

  | Legacy Channel | New Channel       | Function                |
  |----------------|-------------------|-------------------------|
  | status:get     | system:get-status | Get app status          |
  | update:check   | updates:check     | Check for updates       |
  | update:restart | updates:restart   | Restart to apply update |

  They exist because E2E tests (or possibly older code) were still using the old channel names. Rather than break those tests, the
  handlers were kept for backward compatibility during a transition period.

** Build

+ disallow pushing tags on branches other than master
+ add config dir command line param

** Styling

+ larger initial screen size.
+ save screen size in config
+ vertically shrink footer
+ add splash screen with nostling
+ create
+ identities vertically by avatar?
+ enlarge sidebar on large screens

** Release

+ do NOT allow release if test, test-e2e, or lint fails
+ compress git history befor version release
+ compress migrations into one initial migration
+ remove old versions
+ tidy up repo
  + find obsolete classes/functions
  + remove code smells
  + reorganize package layout
  + remove excess comments
  + consolidate tests
+ tidy up ~/Library/Application Support/nostling/
  + there may be unnecessary files

** About

+ about/docs/rationale
  + rationale :: Talk to your friends, and your friends only.
  + about :: Nostling is an easy to use, privacy focussed chat client. It uses the nostr protocol to create identies and transmit messages. On Nostr you don't need email nor registration on any platform. Create your online identies without permission.
  + docs :: private vs. public profile, mnemonic backup (portability), private vs. public key, exchanging npubs
  + technical details :: NIP-59
+ list available versions
+ release notes of latest version
+ repo
+ version
+ status

** [#C]

+ navigate to profile view via three dots(?) and/or double click(?)
+ when navigating to about/relay/config/any menu item, deactivate contact. clicking on contact returns to chat
+ highlight/error log if messages are not kind 4
+ settings:
  + send with enter, line break with shift-enter
+ add nostling icon
+ informative messages in footer should time out and disappear
  + consider swapping footer for info region that appears only on demand
  + consider a small, cute svg animation in footer (only an ostrich neck)
+ generate custom welcome messages in a given language (using llm?)
  + the savanna is ours to conquer
  + looking forward to
  + welcome to my flock
  + ...
+ send images?
+ run all e2e tests in parallel against the same relay in docker compose

** Features

+ scrollable contact list
+ indicate whether a contact is online
+ calendar integration/display, ical
+ add bell icon or desktop feedback when messages arrive
+ allow removing identites
+ search in messages
+ threads
+ mcp interface plugin
  + paid LLM on nostr
+ zaps
+ slash commands, e.g. for payments, avatar generation, etc.
+ TEST :: what happens if two contacts share an alias?
+ rename identities -> profiles
+ hide/delete messages -> "x hidden messages" expand to modal
+ keyboard navigation with arrows and TAB
+ mark new messages as they arrive in main panel (when first displayed, and in visible screen)
+ menu
  + identities ?
    + add/remove
  + contacts ?
    + add/remove/edit
  + relays
+ avatars (generated by llm) train/distill?
+ contact online status?
  + only practical if listening to all messages sent by a contact. (last seen ... ago)
+ languages (dynamic or pre-generated?)
+ settings
  + send on enter/shift enter
+ video calls
+ spell checker
+ automatic language conversion

*** Group Chat

+ fake groups with custom message
+ add member (adding a member creates new id (deterministically?), and starts new chat)
+ @ mentions

** Identity Migration

  What is Electron safeStorage?

  https://www.electronjs.org/docs/latest/api/safe-storage provides OS-native encryption where the encryption key is managed by the OS, not
   the app:

  | OS      | Backend                 | Key Storage          | Protection Scope                         |
  |---------|-------------------------|----------------------|------------------------------------------|
  | macOS   | Keychain Access         | System Keychain      | Per-app (code signature enforced)        |
  | Windows | DPAPI                   | User credentials     | Per-user (not per-app)                   |
  | Linux   | kwallet/gnome-libsecret | Desktop secret store | Varies by DE; may fall back to plaintext |

  Critical insight: The encryption key is tied to the app's identity in the OS. On macOS, if the app is reinstalled, the keychain entry
  may become orphaned/inaccessible because the new app instance gets a new keychain entry.

> is my understanding correct that dev mode does not have access to the OS keychain, because the app was not installed from bundle? 

⏺ Not quite. Dev mode does have access to the keychain - the issue is that the access is unstable across restarts.

  Here's what happens:

  | Scenario          | App Identity (from Keychain's view)          | Keychain Entry                      |
  |-------------------|----------------------------------------------|-------------------------------------|
  | Production bundle | Signed app with stable code signature        | Persistent, same entry every launch |
  | Dev mode          | Unsigned Electron binary / varying signature | May get new entry each session      |

  The Dev Mode Problem

  Session 1: electron . → Keychain creates entry "Electron Safe Storage" with key A
             → encrypt(nsec) with key A → store

  Session 2: electron . → Keychain creates NEW entry with key B (or can't find entry A)
             → decrypt with key B → FAILS
             → fallback to UTF-8 decode → garbage

  
