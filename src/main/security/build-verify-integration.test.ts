/**
 * End-to-end integration test: Build script → Verification library
 *
 * This test validates that manifests generated by scripts/generate-manifest.ts
 * can be successfully verified by src/main/security/verify.ts
 *
 * Critical Property:
 *   Manifests generated during CI/CD build MUST verify in production runtime
 *
 * This test catches payload structure mismatches between build and runtime
 */

import { jest } from '@jest/globals';

jest.mock('../logging', () => ({
  log: jest.fn(),
}));

import crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';
import { verifySignature, verifyManifest } from './verify';
import { SignedManifest, ManifestArtifact } from '../../shared/types';

// Test fixtures: Generate valid RSA keypair for testing
const generateTestKeyPair = () => {
  const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
    modulusLength: 2048,
    publicKeyEncoding: { type: 'spki', format: 'pem' },
    privateKeyEncoding: { type: 'pkcs8', format: 'pem' },
  });
  return { publicKey: publicKey as string, privateKey: privateKey as string };
};

const testKeyPair = generateTestKeyPair();

/**
 * Simulate build script logic: generate manifest same way as scripts/generate-manifest.ts
 */
function simulateBuildScriptGeneration(
  version: string,
  artifacts: ManifestArtifact[],
  privateKeyPem: string
): SignedManifest {
  // This MUST match the exact structure in scripts/generate-manifest.ts
  const unsigned = {
    version,
    artifacts,
    createdAt: new Date().toISOString(),
  };

  // Sign using same algorithm as build script
  const canonicalJson = JSON.stringify(unsigned, null, 0);
  const signer = crypto.createSign('SHA256');
  signer.update(canonicalJson);
  const signature = signer.sign(privateKeyPem, 'base64');

  return {
    ...unsigned,
    signature,
  };
}

describe('Build Script → Verification Library Integration', () => {
  const testArtifacts: ManifestArtifact[] = [
    {
      url: 'Nostling-1.0.0.dmg',
      sha256: 'a'.repeat(64),
      platform: 'darwin',
      type: 'dmg',
    },
    {
      url: 'Nostling-1.0.0.AppImage',
      sha256: 'b'.repeat(64),
      platform: 'linux',
      type: 'AppImage',
    },
  ];

  test('manifest generated by build script logic verifies with library', () => {
    const manifest = simulateBuildScriptGeneration(
      '1.0.0',
      testArtifacts,
      testKeyPair.privateKey
    );

    // This should succeed - verifySignature uses same structure
    const result = verifySignature(manifest, testKeyPair.publicKey);

    expect(result).toBe(true);
  });

  test('build script payload structure matches verification expectations', () => {
    const manifest = simulateBuildScriptGeneration(
      '2.0.0',
      testArtifacts,
      testKeyPair.privateKey
    );

    // Verify the manifest has expected fields
    expect(manifest).toHaveProperty('version');
    expect(manifest).toHaveProperty('artifacts');
    expect(manifest).toHaveProperty('createdAt');
    expect(manifest).toHaveProperty('signature');

    // Verify artifacts have correct structure
    manifest.artifacts.forEach((artifact) => {
      expect(artifact).toHaveProperty('url');
      expect(artifact).toHaveProperty('sha256');
      expect(artifact).toHaveProperty('platform');
      expect(artifact).toHaveProperty('type');
    });

    // Verify signature validates
    expect(verifySignature(manifest, testKeyPair.publicKey)).toBe(true);
  });

  test('modification to any payload field invalidates signature', () => {
    const manifest = simulateBuildScriptGeneration(
      '1.0.0',
      testArtifacts,
      testKeyPair.privateKey
    );

    // Original should verify
    expect(verifySignature(manifest, testKeyPair.publicKey)).toBe(true);

    // Modify version
    const modifiedVersion = { ...manifest, version: '1.0.1' };
    expect(verifySignature(modifiedVersion, testKeyPair.publicKey)).toBe(false);

    // Modify createdAt (use a clearly different timestamp to avoid race condition)
    const modifiedTime = { ...manifest, createdAt: '2000-01-01T00:00:00.000Z' };
    expect(verifySignature(modifiedTime, testKeyPair.publicKey)).toBe(false);

    // Modify artifacts
    const modifiedArtifacts = {
      ...manifest,
      artifacts: [{ ...testArtifacts[0], sha256: 'c'.repeat(64) }],
    };
    expect(verifySignature(modifiedArtifacts, testKeyPair.publicKey)).toBe(false);
  });

  test('end-to-end: build → verify with file hash validation', async () => {
    // Create temp file for testing
    const tmpDir = fs.mkdtempSync(path.join(__dirname, 'test-tmp-'));
    const testFilePath = path.join(tmpDir, 'Nostling-1.0.0.dmg');

    try {
      // Write test file
      const testContent = 'test artifact content';
      fs.writeFileSync(testFilePath, testContent);

      // Compute actual hash
      const hash = crypto.createHash('sha256');
      hash.update(fs.readFileSync(testFilePath));
      const actualHash = hash.digest('hex');

      // Create artifact with actual hash
      const artifact: ManifestArtifact = {
        url: 'Nostling-1.0.0.dmg',
        sha256: actualHash,
        platform: 'darwin',
        type: 'dmg',
      };

      // Generate manifest using build script logic
      const manifest = simulateBuildScriptGeneration(
        '1.0.1',
        [artifact],
        testKeyPair.privateKey
      );

      // Verify using verification library
      const result = await verifyManifest(
        manifest,
        testFilePath,
        '1.0.0',
        'darwin',
        testKeyPair.publicKey
      );

      expect(result).toEqual({ verified: true });
    } finally {
      // Cleanup
      fs.rmSync(tmpDir, { recursive: true, force: true });
    }
  });

  test('timestamp field is included in signature', () => {
    const now = new Date().toISOString();
    const manifest = simulateBuildScriptGeneration(
      '1.0.0',
      testArtifacts,
      testKeyPair.privateKey
    );

    // Signature should be valid
    expect(verifySignature(manifest, testKeyPair.publicKey)).toBe(true);

    // Changing timestamp should invalidate
    const differentTime = new Date(Date.now() + 1000).toISOString();
    const modifiedManifest = { ...manifest, createdAt: differentTime };
    expect(verifySignature(modifiedManifest, testKeyPair.publicKey)).toBe(false);
  });
});
